<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Subnet Calculator & Arcade</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'VT323', monospace;
            background-color: #1A1A2E; /* Dark bluish-purple */
            color: #E0F2E9; /* Light minty */
            display: flex;
            flex-direction: column; /* Stack container and toggle button */
            justify-content: flex-start;
            align-items: center; 
            min-height: 100vh;
            padding: 20px;
            overflow-y: auto; 
        }
        .container {
            background-color: #2A2A4E; /* Slightly lighter dark purple */
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #FF007F; /* Neon pink border */
            box-shadow: 0 0 15px #FF007F, 0 0 5px #FF007F inset;
            width: 100%;
            max-width: 600px;
            margin-top: 20px;
        }
        h1 {
            font-family: 'Press Start 2P', cursive;
            color: #00F0B5; /* Neon teal/green */
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.5rem;
        }
        label {
            color: #00F0B5;
            margin-bottom: 5px;
            display: block;
            font-size: 1.1rem;
        }
        input[type="text"] {
            background-color: #1A1A2E;
            border: 2px solid #FF007F;
            color: #E0F2E9;
            padding: 10px;
            border-radius: 8px;
            width: 100%;
            margin-bottom: 15px;
            font-size: 1rem;
            box-shadow: 0 0 5px #FF007F inset;
        }
        input[type="text"]:read-only {
            background-color: #333;
            cursor: not-allowed;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #00F0B5;
            box-shadow: 0 0 10px #00F0B5;
        }
        button {
            background-color: #FF007F; /* Neon pink */
            color: #1A1A2E;
            font-family: 'Press Start 2P', cursive;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 0 8px #FF007F;
            margin-top: 10px;
            width: 100%;
        }
        button:hover:not(:disabled) {
            background-color: #00F0B5; /* Neon teal/green */
            box-shadow: 0 0 12px #00F0B5;
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            box-shadow: none;
        }
        #hintBtn, #explainBtn {
            background-color: #f0ad4e; /* A nice orange for hints */
        }
        #hintBtn:hover:not(:disabled), #explainBtn:hover:not(:disabled) {
            background-color: #eea236;
        }
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .game-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 10px;
        }
        .result-item {
            background-color: #1A1A2E;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #00F0B5;
            box-shadow: 0 0 5px #00F0B5 inset;
            flex-grow: 1;
            text-align: center;
        }
        .result-item strong {
            color: #FF007F;
            display: block;
            margin-bottom: 5px;
        }
        #livesDisplay {
            color: #FF007F; /* Neon pink hearts */
            font-size: 1.5rem;
            letter-spacing: 0.2rem;
        }
        #messageArea, #feedbackArea, #hintArea, #explanationArea {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            min-height: 40px;
        }
        #hintArea, #explanationArea {
            background-color: #2A2A4E;
            border: 1px dashed #f0ad4e;
            color: #E0F2E9;
            font-size: 1rem;
            white-space: pre-wrap;
            text-align: left;
        }
        .error-message {
            background-color: #FF007F;
            color: #1A1A2E;
            border: 2px solid #E0F2E9;
        }
        .correct-message {
             background-color: #00F0B5;
             color: #1A1A2E;
             border: 2px solid #E0F2E9;
        }
        #modeToggleButton {
            font-size: 0.8rem;
            padding: 12px 20px;
            max-width: 300px;
        }
        #difficultyButtons button {
            margin-right: 10px;
            margin-bottom: 10px;
        }
        #gameArea {
            border: 2px dashed #00F0B5;
            padding: 15px;
            margin-top: 20px;
            border-radius: 10px;
        }
        #questionDisplay {
            font-size: 1.2rem;
            color: #E0F2E9;
            margin-bottom: 15px;
            text-align: center;
        }
        .game-buttons {
            display: flex;
            gap: 10px;
        }
        #multipleChoiceOptions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        #multipleChoiceOptions button {
            font-size: 0.8rem;
            padding: 12px 5px;
        }
        #chatContainer {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        #chatSendBtn {
            width: auto;
            font-size: 0.8rem;
        }

        @media (max-width: 640px) {
            h1 { font-size: 1.25rem; }
            button { font-size: 0.8rem; }
            .results-grid { grid-template-columns: 1fr; }
            .game-buttons { flex-direction: column; }
            #multipleChoiceOptions { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <button id="modeToggleButton">Switch to Arcade Mode</button>

    <!-- Calculator Mode -->
    <div id="calculatorMode" class="container">
        <h1>Subnet Calculator</h1>
        <div>
            <label for="ipAddress">IP Address:</label>
            <input type="text" id="ipAddress" placeholder="e.g., 192.168.1.10">
        </div>
        <div>
            <label for="subnetMask">Subnet Mask:</label>
            <input type="text" id="subnetMask" placeholder="e.g., 255.255.255.0">
        </div>
        <button id="calculateBtn">Calculate</button>
        <button id="explainBtn" style="display: none;">✨ Explain This Subnet</button>
        <div id="messageArea"></div>
        <div class="results-grid">
            <div class="result-item"><strong>Network Address:</strong> <span id="networkAddress">-</span></div>
            <div class="result-item"><strong>Broadcast Address:</strong> <span id="broadcastAddress">-</span></div>
            <div class="result-item"><strong>Number of Hosts:</strong> <span id="numHosts">-</span></div>
            <div class="result-item"><strong>Wildcard Mask:</strong> <span id="wildcardMask">-</span></div>
            <div class="result-item"><strong>Mask Bits (CIDR):</strong> <span id="maskBits">-</span></div>
        </div>
        <div id="explanationArea" style="display: none;"></div>
        <div id="chatContainer" style="display: none;">
            <input type="text" id="chatInput" placeholder="Ask a follow-up question...">
            <button id="chatSendBtn">Send</button>
        </div>
        <button id="generateRandomIpBtn" style="margin-top: 20px;">Generate Random IP</button>
        <div class="result-item" style="margin-top: 10px;">
            <strong>Random IP:</strong> <span id="randomIpResult">-</span>
        </div>
    </div>

    <!-- Arcade Mode -->
    <div id="arcadeMode" class="container" style="display: none;">
        <h1>Arcade Mode</h1>
        <div id="difficultyButtons">
            <p class="text-center mb-4 text-lg">Select Your Difficulty:</p>
            <button data-difficulty="easy">Easy</button>
            <button data-difficulty="medium">Medium</button>
            <button data-difficulty="hard">Hard</button>
        </div>
        <div id="gameArea" style="display: none;">
            <div class="game-stats">
                <div class="result-item"><strong>Score:</strong> <span id="score">0</span></div>
                <div class="result-item"><strong>Question:</strong> <span id="questionCount">1</span> / 50</div>
                <div class="result-item"><strong>Lives:</strong> <span id="livesDisplay">❤️❤️❤️</span></div>
            </div>
            <div id="questionDisplay">Loading question...</div>
            <div id="answerContainer">
                <input type="text" id="answerInput" placeholder="Your answer here...">
                <div id="multipleChoiceOptions"></div>
            </div>
            <div class="game-buttons">
                <button id="prevQuestionBtn">Previous</button>
                <button id="submitAnswerBtn">Submit</button>
            </div>
            <button id="hintBtn">Hint (-1 Life)</button>
            <div id="hintArea" style="display: none;"></div>
            <div id="feedbackArea"></div>
             <button id="quitGameBtn" class="mt-4">Quit Game</button>
        </div>
    </div>

    <!-- Audio files for the game -->
    <audio id="correctAnswerSound" src="subnetcorrect.mp3" preload="auto"></audio>
    <audio id="wrongAnswerSound" src="subnetwrong.mp3" preload="auto"></audio>
    <audio id="gameOverSound" src="subnetgameover.mp3" preload="auto"></audio>

    <script>
        // --- DOM Elements ---
        const ipAddressInput = document.getElementById('ipAddress');
        const subnetMaskInput = document.getElementById('subnetMask');
        const calculateBtn = document.getElementById('calculateBtn');
        const explainBtn = document.getElementById('explainBtn');
        const generateRandomIpBtn = document.getElementById('generateRandomIpBtn');
        const messageArea = document.getElementById('messageArea');
        const networkAddressEl = document.getElementById('networkAddress');
        const broadcastAddressEl = document.getElementById('broadcastAddress');
        const numHostsEl = document.getElementById('numHosts');
        const wildcardMaskEl = document.getElementById('wildcardMask');
        const maskBitsEl = document.getElementById('maskBits');
        const randomIpResultEl = document.getElementById('randomIpResult');
        const explanationArea = document.getElementById('explanationArea');
        const chatContainer = document.getElementById('chatContainer');
        const chatInput = document.getElementById('chatInput');
        const chatSendBtn = document.getElementById('chatSendBtn');
        const modeToggleButton = document.getElementById('modeToggleButton');
        const calculatorModeDiv = document.getElementById('calculatorMode');
        const arcadeModeDiv = document.getElementById('arcadeMode');
        const difficultyButtonsDiv = document.getElementById('difficultyButtons');
        const gameAreaDiv = document.getElementById('gameArea');
        const scoreEl = document.getElementById('score');
        const questionCountEl = document.getElementById('questionCount');
        const livesDisplayEl = document.getElementById('livesDisplay');
        const questionDisplayEl = document.getElementById('questionDisplay');
        const answerInput = document.getElementById('answerInput');
        const multipleChoiceOptionsEl = document.getElementById('multipleChoiceOptions');
        const submitAnswerBtn = document.getElementById('submitAnswerBtn');
        const prevQuestionBtn = document.getElementById('prevQuestionBtn');
        const hintBtn = document.getElementById('hintBtn');
        const hintArea = document.getElementById('hintArea');
        const feedbackArea = document.getElementById('feedbackArea');
        const quitGameBtn = document.getElementById('quitGameBtn');
        const correctAnswerSound = document.getElementById('correctAnswerSound');
        const wrongAnswerSound = document.getElementById('wrongAnswerSound');
        const gameOverSound = document.getElementById('gameOverSound');

        // --- State Variables ---
        let currentNetworkInfo = null;
        let gameQuestions = [];
        let userAnswers = [];
        let hintsUsed = [];
        let activeQuestionIndex = 0;
        let displayIndex = 0;
        let score = 0;
        let lives = 3;
        let currentDifficulty = '';
        let chatHistory = [];

        // --- Helper Functions ---
        function validateIpAddress(ip) {
            const octets = ip.split('.');
            if (octets.length !== 4) return false;
            return octets.every(octetStr => {
                const octet = parseInt(octetStr);
                return !isNaN(octet) && octet >= 0 && octet <= 255;
            }) &&
            (parseInt(octets[0]) >= 1 && parseInt(octets[0]) <= 223) &&
            (parseInt(octets[0]) !== 127) &&
            (parseInt(octets[0]) !== 169 || parseInt(octets[1]) !== 254);
        }

        function validateSubnetMask(mask) {
            const octets = mask.split('.');
            if (octets.length !== 4) return false;
            const numOctets = octets.map(o => parseInt(o));
            if (numOctets.some(isNaN)) return false;
            let binaryMask = numOctets.map(octet => octet.toString(2).padStart(8, '0')).join('');
            return !binaryMask.includes('01');
        }

        function ipToBinary(ip) {
            return ip.split('.').map(octet => parseInt(octet).toString(2).padStart(8, '0')).join('');
        }
        
        function ipToInt(ip) {
            return ip.split('.').reduce((int, octet) => (int << 8) + parseInt(octet), 0);
        }

        function intToIp(int) {
            return [(int >>> 24) & 255, (int >> 16) & 255, (int >> 8) & 255, int & 255].join('.');
        }

        function binaryToIp(binary) {
            const octets = [];
            for (let i = 0; i < 32; i += 8) {
                octets.push(parseInt(binary.substring(i, i + 8), 2).toString());
            }
            return octets.join('.');
        }
        
        function calculateSubnetDetails(ip, mask) {
            if (!validateIpAddress(ip) || !validateSubnetMask(mask)) {
                return null;
            }
            const binaryIp = ipToBinary(ip);
            const binaryMask = ipToBinary(mask);
            const noOfOnes = (binaryMask.match(/1/g) || []).length;
            const noOfZeros = 32 - noOfOnes;
            const numHosts = Math.pow(2, noOfZeros) - 2;
            const networkAddressBinary = binaryIp.substring(0, noOfOnes) + '0'.repeat(noOfZeros);
            const broadcastAddressBinary = binaryIp.substring(0, noOfOnes) + '1'.repeat(noOfZeros);
            const networkAddress = binaryToIp(networkAddressBinary);
            const broadcastAddress = binaryToIp(broadcastAddressBinary);
            const wildcardMask = mask.split('.').map(octet => 255 - parseInt(octet)).join('.');
            const firstHostBinary = networkAddressBinary.slice(0, 31) + '1';
            const lastHostBinary = broadcastAddressBinary.slice(0, 31) + '0';
            return {
                ip, mask, binaryIp, binaryMask,
                networkAddress, broadcastAddress,
                numHosts: numHosts < 0 ? 0 : numHosts,
                wildcardMask, maskBits: noOfOnes,
                firstHost: binaryToIp(firstHostBinary),
                lastHost: binaryToIp(lastHostBinary),
            };
        }

        function clearResults() {
            networkAddressEl.textContent = '-';
            broadcastAddressEl.textContent = '-';
            numHostsEl.textContent = '-';
            wildcardMaskEl.textContent = '-';
            maskBitsEl.textContent = '-';
            randomIpResultEl.textContent = '-';
            explainBtn.style.display = 'none';
            explanationArea.style.display = 'none';
            chatContainer.style.display = 'none';
        }

        // --- Calculator Logic ---
        calculateBtn.addEventListener('click', () => {
            const ip = ipAddressInput.value.trim();
            const mask = subnetMaskInput.value.trim();
            messageArea.textContent = '';
            messageArea.className = '';
            explanationArea.style.display = 'none';
            chatContainer.style.display = 'none';
            chatHistory = [];
            const details = calculateSubnetDetails(ip, mask);
            if (!details) {
                 messageArea.textContent = 'Invalid IP Address or Subnet Mask.';
                 messageArea.classList.add('error-message');
                 clearResults();
                 currentNetworkInfo = null;
                 return;
            }
            networkAddressEl.textContent = details.networkAddress;
            broadcastAddressEl.textContent = details.broadcastAddress;
            numHostsEl.textContent = details.numHosts;
            wildcardMaskEl.textContent = details.wildcardMask;
            maskBitsEl.textContent = `/${details.maskBits}`;
            randomIpResultEl.textContent = '-';
            explainBtn.style.display = 'block';
            currentNetworkInfo = {
                networkAddressOctets: details.networkAddress.split('.').map(o => parseInt(o)),
                numHosts: details.numHosts,
                noOfOnes: details.maskBits
            };
        });

        generateRandomIpBtn.addEventListener('click', () => {
            if (!currentNetworkInfo || currentNetworkInfo.numHosts <= 0) {
                randomIpResultEl.textContent = 'N/A (Calculate subnet first or no hosts)';
                return;
            }
            let netAddrInt = 0;
            currentNetworkInfo.networkAddressOctets.forEach(octet => {
                netAddrInt = (netAddrInt << 8) + octet;
            });
            const randomHostNum = Math.floor(Math.random() * currentNetworkInfo.numHosts) + 1;
            const randomIpInt = netAddrInt + randomHostNum;
            const generatedIpStrParts = [];
            let tempIpInt = randomIpInt;
            for (let i = 0; i < 4; i++) {
                generatedIpStrParts.unshift((tempIpInt & 255).toString());
                tempIpInt >>= 8;
            }
            randomIpResultEl.textContent = generatedIpStrParts.join('.');
        });

        // --- Game Logic ---
        function generateRandomIp(minClassA=1, maxClassC=223) {
            const octet1 = Math.floor(Math.random() * (maxClassC - minClassA + 1)) + minClassA;
            const octet2 = Math.floor(Math.random() * 256);
            const octet3 = Math.floor(Math.random() * 256);
            const octet4 = Math.floor(Math.random() * 254) + 1;
            return `${octet1}.${octet2}.${octet3}.${octet4}`;
        }

        function generateDistractors(correctAnswer, type, details) {
            const distractors = new Set();
            let maxAttempts = 20; // Prevent infinite loops
            while (distractors.size < 3 && maxAttempts > 0) {
                maxAttempts--;
                let wrongAnswer;
                if (type.includes('IP') || type.includes('Address')) {
                    const randomOctet = Math.floor(Math.random() * 255) + 1;
                    const parts = correctAnswer.split('.');
                    parts[3] = (parseInt(parts[3]) + randomOctet) % 256; // Change last octet
                    wrongAnswer = parts.join('.');
                } else if (type.includes('hosts')) {
                    const num = parseInt(correctAnswer);
                    const offset = Math.floor(Math.random() * 5) + 1;
                    wrongAnswer = (Math.random() > 0.5) ? num + offset : Math.max(0, num - offset);
                    wrongAnswer = wrongAnswer.toString();
                } else if (type.includes('CIDR')) {
                    const num = parseInt(correctAnswer.slice(1));
                    const offset = Math.floor(Math.random() * 2) + 1;
                    let newCidr = (Math.random() > 0.5) ? num + offset : num - offset;
                    newCidr = Math.max(1, Math.min(31, newCidr)); // Keep CIDR in a valid range
                    wrongAnswer = `/${newCidr}`;
                }
                if (wrongAnswer && wrongAnswer !== correctAnswer) {
                    distractors.add(wrongAnswer);
                }
            }
            return [...distractors];
        }

        function generateQuestions(difficulty, count) {
            const questions = [];
            const questionTypes = [
                'What is the Network Address?', 'What is the Broadcast Address?',
                'How many usable hosts are there?', 'What is the first usable host IP?',
                'What is the last usable host IP?', 'What is the CIDR notation?'
            ];
            let cidrMin, cidrMax;
            if (difficulty === 'easy') { cidrMin = 24; cidrMax = 30; } 
            else if (difficulty === 'medium') { cidrMin = 16; cidrMax = 23; } 
            else { cidrMin = 8; cidrMax = 30; }

            for (let i = 0; i < count; i++) {
                const ip = generateRandomIp();
                const cidr = Math.floor(Math.random() * (cidrMax - cidrMin + 1)) + cidrMin;
                let maskBinary = '1'.repeat(cidr) + '0'.repeat(32 - cidr);
                const mask = binaryToIp(maskBinary);
                const details = calculateSubnetDetails(ip, mask);
                if (!details) { i--; continue; }
                const questionType = questionTypes[Math.floor(Math.random() * questionTypes.length)];
                let answer;
                switch(questionType) {
                    case 'What is the Network Address?': answer = details.networkAddress; break;
                    case 'What is the Broadcast Address?': answer = details.broadcastAddress; break;
                    case 'How many usable hosts are there?': answer = details.numHosts.toString(); break;
                    case 'What is the first usable host IP?': answer = details.firstHost; break;
                    case 'What is the last usable host IP?': answer = details.lastHost; break;
                    case 'What is the CIDR notation?': answer = `/${details.maskBits}`; break;
                }

                const questionObj = { text: `${questionType}\nFor IP: ${ip}/${cidr}`, answer: answer, details: details };

                if (difficulty === 'easy') {
                    const distractors = generateDistractors(answer, questionType, details);
                    questionObj.options = [...distractors, answer].sort(() => Math.random() - 0.5);
                } else if (difficulty === 'medium') {
                    if (Math.random() > 0.5) {
                        const distractors = generateDistractors(answer, questionType, details);
                        questionObj.options = [...distractors, answer].sort(() => Math.random() - 0.5);
                    }
                }
                questions.push(questionObj);
            }
            return questions;
        }

        function updateLivesDisplay() {
            livesDisplayEl.textContent = '❤️'.repeat(lives);
        }

        function displayQuestion(index) {
            displayIndex = index;
            if (index >= gameQuestions.length) {
                winGame();
                return;
            }
            const question = gameQuestions[index];
            questionDisplayEl.innerText = question.text;
            questionCountEl.textContent = `${index + 1}`;
            prevQuestionBtn.disabled = (index === 0);
            hintBtn.disabled = hintsUsed[index] || (lives <= 0 && currentDifficulty !== 'easy');
            hintArea.style.display = hintsUsed[index] ? 'block' : 'none';
            if (hintsUsed[index]) {
                showHint(true);
            }


            if (question.options) {
                answerInput.style.display = 'none';
                multipleChoiceOptionsEl.style.display = 'grid';
                submitAnswerBtn.style.display = 'none';
                multipleChoiceOptionsEl.innerHTML = '';
                question.options.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option;
                    button.onclick = () => checkAnswer(option);
                    multipleChoiceOptionsEl.appendChild(button);
                });
            } else {
                answerInput.style.display = 'block';
                multipleChoiceOptionsEl.style.display = 'none';
                submitAnswerBtn.style.display = 'block';
                answerInput.value = userAnswers[index] || '';
            }

            if (index < activeQuestionIndex) {
                answerInput.readOnly = true;
                if(question.options) {
                    multipleChoiceOptionsEl.querySelectorAll('button').forEach(btn => btn.disabled = true);
                }
                submitAnswerBtn.textContent = 'Next';
                submitAnswerBtn.style.display = 'block';
                const correctAnswer = question.answer;
                const storedAnswer = userAnswers[index];
                if (storedAnswer && storedAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                    feedbackArea.textContent = 'Your answer was correct!';
                    feedbackArea.className = 'correct-message';
                } else {
                    feedbackArea.textContent = `Your answer was incorrect. Correct answer: ${correctAnswer}`;
                    feedbackArea.className = 'error-message';
                }
            } else {
                answerInput.readOnly = false;
                submitAnswerBtn.textContent = 'Submit';
                feedbackArea.textContent = '';
                feedbackArea.className = '';
                if (!question.options) {
                    answerInput.focus();
                }
            }
        }

        function checkAnswer(selectedOption = null) {
            const userAnswer = selectedOption !== null ? selectedOption : answerInput.value.trim();
            userAnswers[activeQuestionIndex] = userAnswer;
            const correctAnswer = gameQuestions[activeQuestionIndex].answer;
            
            if (userAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                if(correctAnswerSound) {
                    correctAnswerSound.volume = 0.5;
                    correctAnswerSound.currentTime = 0;
                    correctAnswerSound.play().catch(e => console.error("Error playing sound:", e));
                }
                feedbackArea.textContent = 'Correct!';
                feedbackArea.className = 'correct-message';
                score++;
                scoreEl.textContent = score;
            } else {
                if(wrongAnswerSound) {
                    wrongAnswerSound.volume = 0.5;
                    wrongAnswerSound.currentTime = 0;
                    wrongAnswerSound.play().catch(e => console.error("Error playing sound:", e));
                }
                feedbackArea.textContent = `Incorrect! The answer was: ${correctAnswer}`;
                feedbackArea.className = 'error-message';
                lives--;
                updateLivesDisplay();
                if (lives <= 0) {
                    setTimeout(gameOver, 1500);
                    return;
                }
            }
            
            activeQuestionIndex++;
            submitAnswerBtn.disabled = true;
            prevQuestionBtn.disabled = true;
            if(multipleChoiceOptionsEl.style.display === 'grid') {
                multipleChoiceOptionsEl.querySelectorAll('button').forEach(btn => btn.disabled = true);
            }

            setTimeout(() => {
                submitAnswerBtn.disabled = false;
                displayQuestion(activeQuestionIndex);
            }, 1500);
        }

        function showHint(isReview = false) {
            if (lives <= 0 && !isReview && currentDifficulty !== 'easy') return;
            const question = gameQuestions[displayIndex];
            const type = question.text.split('\n')[0];
            let hintText = '';
            const binaryHint = `IP Binary:   ${question.details.binaryIp.match(/.{1,8}/g).join(' . ')}\nMask Binary: ${question.details.binaryMask.match(/.{1,8}/g).join(' . ')}`;

            if (type.includes('Network Address')) {
                hintText = "Hint: The network address is found where the host bits (0s in the mask) are all 0s.\n\n" + binaryHint;
            } else if (type.includes('Broadcast Address')) {
                hintText = "Hint: The broadcast address is found where the host bits (0s in the mask) are all 1s.\n\n" + binaryHint;
            } else if (type.includes('first usable host')) {
                hintText = "Hint: The first usable host is one greater than the network address.\n\n" + binaryHint;
            } else if (type.includes('last usable host')) {
                hintText = "Hint: The last usable host is one less than the broadcast address.\n\n" + binaryHint;
            } else if (type.includes('hosts')) {
                const hostBits = 32 - question.details.maskBits;
                hintText = `Formula: 2^(${hostBits}) - 2`;
            } else if (type.includes('CIDR')) {
                hintText = "Hint: Count the number of '1's in the subnet mask's binary form.";
            }

            hintArea.innerText = hintText;
            hintArea.style.display = 'block';

            if (!isReview) {
                if (currentDifficulty !== 'easy') {
                    lives--;
                    updateLivesDisplay();
                }
                hintsUsed[displayIndex] = true;
                hintBtn.disabled = true;
                if (lives <= 0) {
                    setTimeout(gameOver, 2000);
                }
            }
        }

        function startGame(difficulty) {
            score = 0;
            lives = 3;
            activeQuestionIndex = 0;
            displayIndex = 0;
            currentDifficulty = difficulty;
            userAnswers = new Array(50).fill(null);
            hintsUsed = new Array(50).fill(false);
            scoreEl.textContent = '0';
            updateLivesDisplay();
            gameQuestions = generateQuestions(difficulty, 50);
            difficultyButtonsDiv.style.display = 'none';
            gameAreaDiv.style.display = 'block';
            submitAnswerBtn.style.display = 'block';
            prevQuestionBtn.style.display = 'block';
            hintBtn.style.display = 'block';
            if (difficulty === 'easy') {
                hintBtn.textContent = 'Hint (Free)';
            } else {
                hintBtn.textContent = 'Hint (-1 Life)';
            }
            displayQuestion(0);
        }

        function winGame() {
            questionDisplayEl.innerText = `You completed the level!\nYour final score is ${score} out of 50.`;
            answerInput.style.display = 'none';
            submitAnswerBtn.style.display = 'none';
            prevQuestionBtn.style.display = 'none';
            hintBtn.style.display = 'none';
            multipleChoiceOptionsEl.style.display = 'none';
            feedbackArea.textContent = '';
            feedbackArea.className = '';

            let badgeName = '';
            let badgeDisplayName = '';
            if (currentDifficulty === 'easy') { badgeName = 'networknovice'; badgeDisplayName = 'Network Novice'; } 
            else if (currentDifficulty === 'medium') { badgeName = 'networktechnician'; badgeDisplayName = 'Network Technician'; } 
            else if (currentDifficulty === 'hard') { badgeName = 'networkadmin'; badgeDisplayName = 'Network Admin'; }

            if (badgeName && window.parent && typeof window.parent.awardBadge === 'function') {
                try {
                    window.parent.awardBadge(badgeName, badgeDisplayName);
                } catch (e) {
                    console.error("Could not award badge. Error communicating with parent window:", e);
                }
            } else {
                 console.log("Not in an iframe or parent awardBadge function not found. Badge not awarded.");
            }
        }

        function gameOver() {
            if(gameOverSound) {
                gameOverSound.volume = 0.5;
                gameOverSound.currentTime = 0;
                gameOverSound.play().catch(e => console.error("Error playing sound:", e));
            }
            questionDisplayEl.innerText = `Game Over!\nYou ran out of lives.\nYour final score is ${score}.`;
            answerInput.style.display = 'none';
            submitAnswerBtn.style.display = 'none';
            prevQuestionBtn.style.display = 'none';
            hintBtn.style.display = 'none';
            multipleChoiceOptionsEl.style.display = 'none';
            feedbackArea.textContent = '';
            feedbackArea.className = '';
        }
        
        function quitGame() {
             difficultyButtonsDiv.style.display = 'block';
             gameAreaDiv.style.display = 'none';
             hintBtn.style.display = 'block';
             hintBtn.textContent = 'Hint (-1 Life)';
             currentDifficulty = '';
        }

        // --- Gemini API Integration ---
        function renderChatHistory() {
            explanationArea.innerHTML = '';
            chatHistory.forEach((message, index) => {
                // This condition hides the initial system prompt from the user view
                if (index === 0 && message.role === 'user') return;

                const messageDiv = document.createElement('div');
                const messageP = document.createElement('p');
                messageP.innerText = message.parts[0].text;
                
                if (message.role === 'user') {
                    messageDiv.className = 'flex justify-end my-2';
                    messageP.className = 'bg-[#FF007F] text-[#1A1A2E] p-3 rounded-lg max-w-xs md:max-w-md';
                } else {
                    messageDiv.className = 'flex justify-start my-2';
                    messageP.className = 'bg-[#00F0B5] text-[#1A1A2E] p-3 rounded-lg max-w-xs md:max-w-md';
                }
                
                messageDiv.appendChild(messageP);
                explanationArea.appendChild(messageDiv);
            });
            explanationArea.scrollTop = explanationArea.scrollHeight; // Scroll to bottom
        }

        async function callGeminiAPI() {
            chatSendBtn.disabled = true;
            const thinkingP = document.createElement('p');
            thinkingP.innerText = '✨ Thinking...';
            thinkingP.className = 'bg-[#00F0B5] text-[#1A1A2E] p-3 rounded-lg max-w-xs md:max-w-md';
            const thinkingDiv = document.createElement('div');
            thinkingDiv.className = 'flex justify-start my-2';
            thinkingDiv.appendChild(thinkingP);
            explanationArea.appendChild(thinkingDiv);
            
            try {
                const payload = { contents: chatHistory };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
                
                const result = await response.json();
                
                if (result.candidates && result.candidates[0].content.parts[0].text) {
                    chatHistory.push({ role: 'model', parts: [{ text: result.candidates[0].content.parts[0].text }] });
                } else {
                    chatHistory.push({ role: 'model', parts: [{ text: 'Sorry, I could not get a response.' }] });
                }
            } catch (error) {
                console.error("Gemini API Error:", error);
                chatHistory.push({ role: 'model', parts: [{ text: 'Sorry, an error occurred. Please try again.' }] });
            } finally {
                renderChatHistory();
                chatSendBtn.disabled = false;
            }
        }

        async function getInitialExplanation() {
            explanationArea.style.display = 'block';
            explanationArea.innerHTML = ''; // Clear previous content
            explainBtn.disabled = true;
            chatHistory = []; // Reset history

            const ip = ipAddressInput.value;
            const mask = subnetMaskInput.value;
            const network = networkAddressEl.textContent;
            const broadcast = broadcastAddressEl.textContent;
            const hosts = numHostsEl.textContent;

            const prompt = `
                Briefly explain the following subnet information in 3-4 sentences for a networking student.
                - Initial IP Address: ${ip}
                - Subnet Mask: ${mask}
                - Calculated Network Address: ${network}
                - Calculated Broadcast Address: ${broadcast}
                - Number of Usable Hosts: ${hosts}
            `;
            
            chatHistory.push({ role: 'user', parts: [{ text: prompt }] });
            await callGeminiAPI();
            chatContainer.style.display = 'flex';
            explainBtn.disabled = false;
        }

        async function handleChatSubmit() {
            const userInput = chatInput.value.trim();
            if (!userInput) return;
            
            chatHistory.push({ role: 'user', parts: [{ text: userInput }] });
            chatInput.value = '';
            renderChatHistory();
            await callGeminiAPI();
        }

        // --- Event Listeners ---
        modeToggleButton.addEventListener('click', () => {
            const isCalculatorVisible = calculatorModeDiv.style.display !== 'none';
            if (isCalculatorVisible) {
                calculatorModeDiv.style.display = 'none';
                arcadeModeDiv.style.display = 'block';
                modeToggleButton.textContent = 'Switch to Calculator Mode';
            } else {
                calculatorModeDiv.style.display = 'block';
                arcadeModeDiv.style.display = 'none';
                modeToggleButton.textContent = 'Switch to Arcade Mode';
                quitGame();
            }
        });

        difficultyButtonsDiv.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                const difficulty = e.target.dataset.difficulty;
                startGame(difficulty);
            }
        });
        
        submitAnswerBtn.addEventListener('click', () => {
            if (submitAnswerBtn.textContent === 'Submit') {
                checkAnswer();
            } else { // It's a 'Next' button
                if (displayIndex < activeQuestionIndex) {
                    displayQuestion(displayIndex + 1);
                }
            }
        });

        prevQuestionBtn.addEventListener('click', () => {
            if (displayIndex > 0) {
                displayQuestion(displayIndex - 1);
            }
        });

        hintBtn.addEventListener('click', () => showHint(false));
        explainBtn.addEventListener('click', getInitialExplanation);
        chatSendBtn.addEventListener('click', handleChatSubmit);
        chatInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                handleChatSubmit();
            }
        });

        answerInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter' && submitAnswerBtn.textContent === 'Submit') {
                checkAnswer();
            }
        });
        
        quitGameBtn.addEventListener('click', quitGame);

    </script>
</body>
</html>
