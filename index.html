<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Subnet Calculator & Arcade</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'VT323', monospace;
            background-color: #1A1A2E; /* Dark bluish-purple */
            color: #E0F2E9; /* Light minty */
            display: flex;
            flex-direction: column; /* Stack container and toggle button */
            justify-content: flex-start;
            align-items: center; 
            min-height: 100vh;
            padding: 20px;
            overflow-y: auto; 
        }
        .container {
            background-color: #2A2A4E; /* Slightly lighter dark purple */
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #FF007F; /* Neon pink border */
            box-shadow: 0 0 15px #FF007F, 0 0 5px #FF007F inset;
            width: 100%;
            max-width: 600px;
            margin-top: 20px;
        }
        h1 {
            font-family: 'Press Start 2P', cursive;
            color: #00F0B5; /* Neon teal/green */
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.5rem;
        }
        label {
            color: #00F0B5;
            margin-bottom: 5px;
            display: block;
            font-size: 1.1rem;
        }
        input[type="text"] {
            background-color: #1A1A2E;
            border: 2px solid #FF007F;
            color: #E0F2E9;
            padding: 10px;
            border-radius: 8px;
            width: 100%;
            margin-bottom: 15px;
            font-size: 1rem;
            box-shadow: 0 0 5px #FF007F inset;
        }
        input[type="text"]:read-only {
            background-color: #333;
            cursor: not-allowed;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #00F0B5;
            box-shadow: 0 0 10px #00F0B5;
        }
        button {
            background-color: #FF007F; /* Neon pink */
            color: #1A1A2E;
            font-family: 'Press Start 2P', cursive;
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 0 8px #FF007F;
            margin-top: 10px;
            width: 100%;
        }
        button:hover:not(:disabled) {
            background-color: #00F0B5; /* Neon teal/green */
            box-shadow: 0 0 12px #00F0B5;
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            box-shadow: none;
        }
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .result-item {
            background-color: #1A1A2E;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #00F0B5;
            box-shadow: 0 0 5px #00F0B5 inset;
        }
        .result-item strong {
            color: #FF007F;
            display: block;
            margin-bottom: 5px;
        }
        #messageArea, #feedbackArea {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            min-height: 40px;
        }
        .error-message {
            background-color: #FF007F;
            color: #1A1A2E;
            border: 2px solid #E0F2E9;
        }
        .correct-message {
             background-color: #00F0B5;
             color: #1A1A2E;
             border: 2px solid #E0F2E9;
        }
        #modeToggleButton {
            font-size: 0.8rem;
            padding: 12px 20px;
            max-width: 300px;
        }
        #difficultyButtons button {
            margin-right: 10px;
            margin-bottom: 10px;
        }
        #gameArea {
            border: 2px dashed #00F0B5;
            padding: 15px;
            margin-top: 20px;
            border-radius: 10px;
        }
        #questionDisplay {
            font-size: 1.2rem;
            color: #E0F2E9;
            margin-bottom: 15px;
            text-align: center;
        }
        .game-buttons {
            display: flex;
            gap: 10px;
        }

        @media (max-width: 640px) {
            h1 { font-size: 1.25rem; }
            button { font-size: 0.8rem; }
            .results-grid { grid-template-columns: 1fr; }
            .game-buttons { flex-direction: column; }
        }
    </style>
</head>
<body>
    <button id="modeToggleButton">Switch to Arcade Mode</button>

    <!-- Calculator Mode -->
    <div id="calculatorMode" class="container">
        <h1>Subnet Calculator</h1>
        <div>
            <label for="ipAddress">IP Address:</label>
            <input type="text" id="ipAddress" placeholder="e.g., 192.168.1.10">
        </div>
        <div>
            <label for="subnetMask">Subnet Mask:</label>
            <input type="text" id="subnetMask" placeholder="e.g., 255.255.255.0">
        </div>
        <button id="calculateBtn">Calculate</button>
        <div id="messageArea"></div>
        <div class="results-grid">
            <div class="result-item"><strong>Network Address:</strong> <span id="networkAddress">-</span></div>
            <div class="result-item"><strong>Broadcast Address:</strong> <span id="broadcastAddress">-</span></div>
            <div class="result-item"><strong>Number of Hosts:</strong> <span id="numHosts">-</span></div>
            <div class="result-item"><strong>Wildcard Mask:</strong> <span id="wildcardMask">-</span></div>
            <div class="result-item"><strong>Mask Bits (CIDR):</strong> <span id="maskBits">-</span></div>
        </div>
        <button id="generateRandomIpBtn" style="margin-top: 20px;">Generate Random IP</button>
        <div class="result-item" style="margin-top: 10px;">
            <strong>Random IP:</strong> <span id="randomIpResult">-</span>
        </div>
    </div>

    <!-- Arcade Mode -->
    <div id="arcadeMode" class="container" style="display: none;">
        <h1>Arcade Mode</h1>
        <div id="difficultyButtons">
            <p class="text-center mb-4 text-lg">Select Your Difficulty:</p>
            <button data-difficulty="easy">Easy</button>
            <button data-difficulty="medium">Medium</button>
            <button data-difficulty="hard">Hard</button>
        </div>
        <div id="gameArea" style="display: none;">
            <div class="flex justify-between mb-4">
                <div class="result-item"><strong>Score:</strong> <span id="score">0</span></div>
                <div class="result-item"><strong>Question:</strong> <span id="questionCount">1</span> / 50</div>
            </div>
            <div id="questionDisplay">Loading question...</div>
            <input type="text" id="answerInput" placeholder="Your answer here...">
            <div class="game-buttons">
                <button id="prevQuestionBtn">Previous</button>
                <button id="submitAnswerBtn">Submit</button>
            </div>
            <div id="feedbackArea"></div>
             <button id="quitGameBtn" class="mt-4">Quit Game</button>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const ipAddressInput = document.getElementById('ipAddress');
        const subnetMaskInput = document.getElementById('subnetMask');
        const calculateBtn = document.getElementById('calculateBtn');
        const generateRandomIpBtn = document.getElementById('generateRandomIpBtn');
        const messageArea = document.getElementById('messageArea');
        const networkAddressEl = document.getElementById('networkAddress');
        const broadcastAddressEl = document.getElementById('broadcastAddress');
        const numHostsEl = document.getElementById('numHosts');
        const wildcardMaskEl = document.getElementById('wildcardMask');
        const maskBitsEl = document.getElementById('maskBits');
        const randomIpResultEl = document.getElementById('randomIpResult');
        const modeToggleButton = document.getElementById('modeToggleButton');
        const calculatorModeDiv = document.getElementById('calculatorMode');
        const arcadeModeDiv = document.getElementById('arcadeMode');
        const difficultyButtonsDiv = document.getElementById('difficultyButtons');
        const gameAreaDiv = document.getElementById('gameArea');
        const scoreEl = document.getElementById('score');
        const questionCountEl = document.getElementById('questionCount');
        const questionDisplayEl = document.getElementById('questionDisplay');
        const answerInput = document.getElementById('answerInput');
        const submitAnswerBtn = document.getElementById('submitAnswerBtn');
        const prevQuestionBtn = document.getElementById('prevQuestionBtn');
        const feedbackArea = document.getElementById('feedbackArea');
        const quitGameBtn = document.getElementById('quitGameBtn');

        // --- State Variables ---
        let currentNetworkInfo = null;
        let gameQuestions = [];
        let userAnswers = [];
        let activeQuestionIndex = 0; // The "frontier" of questions the user has answered
        let displayIndex = 0; // The question currently being displayed
        let score = 0;
        let currentDifficulty = '';

        // --- Helper Functions ---
        function validateIpAddress(ip) {
            const octets = ip.split('.');
            if (octets.length !== 4) return false;
            return octets.every(octetStr => {
                const octet = parseInt(octetStr);
                return !isNaN(octet) && octet >= 0 && octet <= 255;
            }) &&
            (parseInt(octets[0]) >= 1 && parseInt(octets[0]) <= 223) &&
            (parseInt(octets[0]) !== 127) &&
            (parseInt(octets[0]) !== 169 || parseInt(octets[1]) !== 254);
        }

        function validateSubnetMask(mask) {
            const octets = mask.split('.');
            if (octets.length !== 4) return false;
            const numOctets = octets.map(o => parseInt(o));
            if (numOctets.some(isNaN)) return false;
            let binaryMask = numOctets.map(octet => octet.toString(2).padStart(8, '0')).join('');
            return !binaryMask.includes('01');
        }

        function ipToBinary(ip) {
            return ip.split('.').map(octet => parseInt(octet).toString(2).padStart(8, '0')).join('');
        }

        function binaryToIp(binary) {
            const octets = [];
            for (let i = 0; i < 32; i += 8) {
                octets.push(parseInt(binary.substring(i, i + 8), 2).toString());
            }
            return octets.join('.');
        }
        
        function calculateSubnetDetails(ip, mask) {
            if (!validateIpAddress(ip) || !validateSubnetMask(mask)) {
                return null;
            }
            const binaryIp = ipToBinary(ip);
            const binaryMask = ipToBinary(mask);
            const noOfOnes = (binaryMask.match(/1/g) || []).length;
            const noOfZeros = 32 - noOfOnes;
            const numHosts = Math.pow(2, noOfZeros) - 2;
            const networkAddressBinary = binaryIp.substring(0, noOfOnes) + '0'.repeat(noOfZeros);
            const broadcastAddressBinary = binaryIp.substring(0, noOfOnes) + '1'.repeat(noOfZeros);
            const networkAddress = binaryToIp(networkAddressBinary);
            const broadcastAddress = binaryToIp(broadcastAddressBinary);
            const wildcardMask = mask.split('.').map(octet => 255 - parseInt(octet)).join('.');
            
            const firstHostBinary = networkAddressBinary.slice(0, 31) + '1';
            const lastHostBinary = broadcastAddressBinary.slice(0, 31) + '0';

            return {
                networkAddress,
                broadcastAddress,
                numHosts: numHosts < 0 ? 0 : numHosts,
                wildcardMask,
                maskBits: noOfOnes,
                firstHost: binaryToIp(firstHostBinary),
                lastHost: binaryToIp(lastHostBinary),
            };
        }

        function clearResults() {
            networkAddressEl.textContent = '-';
            broadcastAddressEl.textContent = '-';
            numHostsEl.textContent = '-';
            wildcardMaskEl.textContent = '-';
            maskBitsEl.textContent = '-';
            randomIpResultEl.textContent = '-';
        }

        // --- Calculator Logic ---
        calculateBtn.addEventListener('click', () => {
            const ip = ipAddressInput.value.trim();
            const mask = subnetMaskInput.value.trim();
            messageArea.textContent = '';
            messageArea.className = '';
            const details = calculateSubnetDetails(ip, mask);
            if (!details) {
                 messageArea.textContent = 'Invalid IP Address or Subnet Mask.';
                 messageArea.classList.add('error-message');
                 clearResults();
                 currentNetworkInfo = null;
                 return;
            }
            networkAddressEl.textContent = details.networkAddress;
            broadcastAddressEl.textContent = details.broadcastAddress;
            numHostsEl.textContent = details.numHosts;
            wildcardMaskEl.textContent = details.wildcardMask;
            maskBitsEl.textContent = `/${details.maskBits}`;
            randomIpResultEl.textContent = '-';
            currentNetworkInfo = {
                networkAddressOctets: details.networkAddress.split('.').map(o => parseInt(o)),
                numHosts: details.numHosts,
                noOfOnes: details.maskBits
            };
        });

        generateRandomIpBtn.addEventListener('click', () => {
            if (!currentNetworkInfo || currentNetworkInfo.numHosts <= 0) {
                randomIpResultEl.textContent = 'N/A (Calculate subnet first or no hosts)';
                return;
            }
            let netAddrInt = 0;
            currentNetworkInfo.networkAddressOctets.forEach(octet => {
                netAddrInt = (netAddrInt << 8) + octet;
            });
            const randomHostNum = Math.floor(Math.random() * currentNetworkInfo.numHosts) + 1;
            const randomIpInt = netAddrInt + randomHostNum;
            const generatedIpStrParts = [];
            let tempIpInt = randomIpInt;
            for (let i = 0; i < 4; i++) {
                generatedIpStrParts.unshift((tempIpInt & 255).toString());
                tempIpInt >>= 8;
            }
            randomIpResultEl.textContent = generatedIpStrParts.join('.');
        });

        // --- Game Logic ---
        function generateRandomIp(minClassA=1, maxClassC=223) {
            const octet1 = Math.floor(Math.random() * (maxClassC - minClassA + 1)) + minClassA;
            const octet2 = Math.floor(Math.random() * 256);
            const octet3 = Math.floor(Math.random() * 256);
            const octet4 = Math.floor(Math.random() * 254) + 1;
            return `${octet1}.${octet2}.${octet3}.${octet4}`;
        }

        function generateQuestions(difficulty, count) {
            const questions = [];
            const questionTypes = [
                'What is the Network Address?', 'What is the Broadcast Address?',
                'How many usable hosts are there?', 'What is the first usable host IP?',
                'What is the last usable host IP?', 'What is the CIDR notation?'
            ];
            let cidrMin, cidrMax;
            if (difficulty === 'easy') { cidrMin = 24; cidrMax = 30; } 
            else if (difficulty === 'medium') { cidrMin = 16; cidrMax = 23; } 
            else { cidrMin = 8; cidrMax = 30; }

            for (let i = 0; i < count; i++) {
                const ip = generateRandomIp();
                const cidr = Math.floor(Math.random() * (cidrMax - cidrMin + 1)) + cidrMin;
                let maskBinary = '1'.repeat(cidr) + '0'.repeat(32 - cidr);
                const mask = binaryToIp(maskBinary);
                const details = calculateSubnetDetails(ip, mask);
                if (!details) { i--; continue; }
                const questionType = questionTypes[Math.floor(Math.random() * questionTypes.length)];
                let answer;
                switch(questionType) {
                    case 'What is the Network Address?': answer = details.networkAddress; break;
                    case 'What is the Broadcast Address?': answer = details.broadcastAddress; break;
                    case 'How many usable hosts are there?': answer = details.numHosts.toString(); break;
                    case 'What is the first usable host IP?': answer = details.firstHost; break;
                    case 'What is the last usable host IP?': answer = details.lastHost; break;
                    case 'What is the CIDR notation?': answer = `/${details.maskBits}`; break;
                }
                questions.push({ text: `${questionType}\nFor IP: ${ip} with mask ${mask}`, answer: answer });
            }
            return questions;
        }

        function displayQuestion(index) {
            displayIndex = index;
            if (index >= gameQuestions.length) {
                endGame();
                return;
            }
            const question = gameQuestions[index];
            questionDisplayEl.innerText = question.text;
            questionCountEl.textContent = `${index + 1}`;
            answerInput.value = userAnswers[index] || '';
            prevQuestionBtn.disabled = (index === 0);

            if (index < activeQuestionIndex) { // Reviewing a past question
                answerInput.readOnly = true;
                submitAnswerBtn.textContent = 'Next';
                const correctAnswer = gameQuestions[index].answer;
                const storedAnswer = userAnswers[index];
                if (storedAnswer && storedAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                    feedbackArea.textContent = 'Your answer was correct!';
                    feedbackArea.className = 'correct-message';
                } else {
                    feedbackArea.textContent = `Your answer was incorrect. Correct answer: ${correctAnswer}`;
                    feedbackArea.className = 'error-message';
                }
            } else { // On the active question
                answerInput.readOnly = false;
                submitAnswerBtn.textContent = 'Submit';
                feedbackArea.textContent = '';
                feedbackArea.className = '';
                answerInput.focus();
            }
        }

        function checkAnswer() {
            const userAnswer = answerInput.value.trim();
            userAnswers[activeQuestionIndex] = userAnswer;
            const correctAnswer = gameQuestions[activeQuestionIndex].answer;
            
            if (userAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                feedbackArea.textContent = 'Correct!';
                feedbackArea.className = 'correct-message';
            } else {
                feedbackArea.textContent = `Incorrect! The answer was: ${correctAnswer}`;
                feedbackArea.className = 'error-message';
            }
            recalculateScore();
            activeQuestionIndex++;
            submitAnswerBtn.disabled = true;
            prevQuestionBtn.disabled = true;
            setTimeout(() => {
                submitAnswerBtn.disabled = false;
                displayQuestion(activeQuestionIndex);
            }, 1500);
        }

        function recalculateScore() {
            score = 0;
            // Only score questions up to the active (latest answered) index
            for(let i = 0; i < activeQuestionIndex + 1; i++) {
                if(userAnswers[i] && gameQuestions[i] && userAnswers[i].toLowerCase() === gameQuestions[i].answer.toLowerCase()) {
                    score++;
                }
            }
            scoreEl.textContent = score;
        }

        function startGame(difficulty) {
            score = 0;
            activeQuestionIndex = 0;
            displayIndex = 0;
            currentDifficulty = difficulty;
            userAnswers = new Array(50).fill(null);
            scoreEl.textContent = '0';
            gameQuestions = generateQuestions(difficulty, 50);
            difficultyButtonsDiv.style.display = 'none';
            gameAreaDiv.style.display = 'block';
            answerInput.style.display = 'block';
            submitAnswerBtn.style.display = 'block';
            prevQuestionBtn.style.display = 'block';
            displayQuestion(0);
        }

        function endGame() {
            questionDisplayEl.innerText = `Game Over!\nYour final score is ${score} out of 50.`;
            answerInput.style.display = 'none';
            submitAnswerBtn.style.display = 'none';
            prevQuestionBtn.style.display = 'none';
            feedbackArea.textContent = '';
            feedbackArea.className = '';

            if (score === 50) {
                let badgeName = '';
                let badgeDisplayName = '';
                if (currentDifficulty === 'easy') { badgeName = 'networknovice'; badgeDisplayName = 'Network Novice'; } 
                else if (currentDifficulty === 'medium') { badgeName = 'networktechnician'; badgeDisplayName = 'Network Technician'; } 
                else if (currentDifficulty === 'hard') { badgeName = 'networkadmin'; badgeDisplayName = 'Network Admin'; }

                if (badgeName && window.parent && typeof window.parent.awardBadge === 'function') {
                    try {
                        window.parent.awardBadge(badgeName, badgeDisplayName);
                    } catch (e) {
                        console.error("Could not award badge. Error communicating with parent window:", e);
                    }
                } else {
                     console.log("Not in an iframe or parent awardBadge function not found. Badge not awarded.");
                }
            }
        }
        
        function quitGame() {
             difficultyButtonsDiv.style.display = 'block';
             gameAreaDiv.style.display = 'none';
             answerInput.style.display = 'block';
             submitAnswerBtn.style.display = 'block';
             submitAnswerBtn.textContent = 'Submit';
             prevQuestionBtn.style.display = 'block';
             currentDifficulty = '';
        }

        // --- Event Listeners ---
        modeToggleButton.addEventListener('click', () => {
            const isCalculatorVisible = calculatorModeDiv.style.display !== 'none';
            if (isCalculatorVisible) {
                calculatorModeDiv.style.display = 'none';
                arcadeModeDiv.style.display = 'block';
                modeToggleButton.textContent = 'Switch to Calculator Mode';
            } else {
                calculatorModeDiv.style.display = 'block';
                arcadeModeDiv.style.display = 'none';
                modeToggleButton.textContent = 'Switch to Arcade Mode';
                quitGame();
            }
        });

        difficultyButtonsDiv.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') {
                const difficulty = e.target.dataset.difficulty;
                startGame(difficulty);
            }
        });
        
        submitAnswerBtn.addEventListener('click', () => {
            if (submitAnswerBtn.textContent === 'Submit') {
                checkAnswer();
            } else { // It's a 'Next' button
                if (displayIndex < activeQuestionIndex) {
                    displayQuestion(displayIndex + 1);
                }
            }
        });

        prevQuestionBtn.addEventListener('click', () => {
            if (displayIndex > 0) {
                displayQuestion(displayIndex - 1);
            }
        });

        answerInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter' && submitAnswerBtn.textContent === 'Submit') {
                checkAnswer();
            }
        });
        
        quitGameBtn.addEventListener('click', quitGame);

    </script>
</body>
</html>
